E(dfgraph)[[1]][1]
E(dfgraph)[[1]]
E(dfgraph)[[2]]
E(dfgraph)[[]]
E(dfgraph)(which(E(dfgraph)[[]]==3))
E(dfgraph)(which(3 %in% E(dfgraph)[[]]))
E(dfgraph)(which(E(dfgraph)[[]]))
E(dfgraph)(which(3 %in% E(dfgraph)[[]]))
E(dfgraph)[[]]
E(dfgraph)[[]]==3
E(dfgraph)[[]][1]==3
E(dfgraph)[[]][1]
E(dfgraph)[[]][2]
E(dfgraph)[[1]][p1]
E(dfgraph)[[1]][1]
E(dfgraph)[[1]][2]
E(dfgraph)[[1]]
E(dfgraph)[[1]][1]
E(dfgraph)[[1]]$tail
E(dfgraph)$tail
E(dfgraph)[[]]$head
str(E(dfgraph))
str(E(dfgraph))
E(dfgraph)$vnames
E(dfgraph)$vnames ==
23
E(dfgraph)$vnames
E(dfgraph)$names
E(dfgraph)$edges
E(dfgraph)$tail
E(dfgraph)[[]]$tail
E(dfgraph)[]$taile
E(dfgraph)[]$tail
E(dfgraph)$env
E(dfgraph)$vnames
head_of(dfgraph, 3)
head_of(dfgraph, 1)
E(dfgraph)
head_of(dfgraph, 2)
head_of(dfgraph, 3)
head_of(dfgraph, 4)
head_of(dfgraph, 5)
tail_of(dfgraph_1)
tail_of(dfgraph, 1)
tail_of(dfgraph)
tail_of(dfgraph, *)
tail_of(dfgraph)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column( 12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk=="") {#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
		}#
		ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
		eulerwalk <- paste(eulerwalk, ",", ver)#
		output$walk <- renderText(eulerwalk)#
    output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red")		#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk=="") {#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
		}#
		ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
		eulerwalk <- paste(eulerwalk, ",", ver)#
		output$walk <- renderText(eulerwalk)#
    output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red")		#
	})#
}
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column( 12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk=="") {#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
		}#
		ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
		eulerwalk <- paste(eulerwalk, ",", ver)#
		output$walk <- renderText(eulerwalk)#
    output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column( 12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
		ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
		eulerwalk <- paste(eulerwalk, ",", ver)#
		output$walk <- renderText(eulerwalk)#
    output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column( 12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		eulerwalk <- paste(ver)#
    		output$walk <- print(eulerwalk)#
		ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
		eulerwalk <- paste(eulerwalk, ",", ver)#
		output$walk <- renderText(eulerwalk)#
    output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column( 12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
#    		eulerwalk <- paste(ver)#
    		output$walk <- renderText(ver)#
		ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
		eulerwalk <- paste(eulerwalk, ",", ver)#
		output$walk <- renderText(eulerwalk)#
    output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
edges_df <- euler.makeDataFrame(6)
eulerwalk <- ""
node_names <- c(1:nrow(edges_df))
dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names)
coords <<- layout_(dfgraph, as_star())
output$graph <- renderPlot(plot(dfgraph, layout=coords))
output$graph <- renderPlot(plot(dfgraph, layout=coords))
ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)
ver <- which(coords[,1]==0 && coords[,2]==0)
ver
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
		eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
		ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
		eulerwalk <- paste(eulerwalk, ",", ver)#
		output$walk <- renderText(eulerwalk)#
    output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
	})#
}
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column( 12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    	output$walk <- renderText(eulerwalk)#
    })#
    observeEvent(input$plot_click, {#
    	ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
			eulerwalk <- paste(ver)#
    	output$walk <- renderText(eulerwalk)#
		ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
		eulerwalk <- paste(eulerwalk, ",", ver)#
		output$walk <- renderText(eulerwalk)#
    output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk", click = "plot_click"),#
		)#
	)#
)#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column( 12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    	output$walk <- renderText(eulerwalk)#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk == ""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk", click = "plot_click"),#
		)#
	)#
)
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column( 12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
)#
)
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk", click = "plot_click"),#
		)#
	)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk", click = "plot_click"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    	output$walk <- renderText(eulerwalk)#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk == ""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    	output$walk <- renderText(eulerwalk)#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk == ""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk == ""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
    	} #
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk == ""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderUI(eulerwalk)#
    	} #
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(ver == NULL){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk == ""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderText(h3(eulerwalk))#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- c()#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(length(eulerwalk) == 0){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- c(eulerwalk, ver)#
    		output$walk <- renderText(ver)#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- c()#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(length(eulerwalk) == 0){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- c(eulerwalk, ver)#
    		output$walk <- renderText(1)#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- c()#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(length(eulerwalk) == 0){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		if (ver == NULL) {#
				eulerwalk <- c(eulerwalk, ver)#
    		output$walk <- renderText("x")    			#
    		}#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- c()#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(length(eulerwalk) == 0){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		if (ver == NULL) {#
				eulerwalk <- c(eulerwalk, ver)#
    		output$walk <- renderText("x")    			#
    		}#
    		eulerwalk <- c(eulerwalk, ver)#
    		output$walk <- renderText(1)#
#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- c()#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(length(eulerwalk) == 0){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
#
    		output$walk <- renderText(ver)#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
    	} else {#
				ver <- which(coords[,1] == input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
eulerwalk <- ""
if(eulerwalk==""){#
    		ver <- which(coords[,1]==0 && coords[,2]==0)#
				eulerwalk <- paste(ver)#
    		output$walk <- renderText(eulerwalk)#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste(eulerwalk, ",", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}
if(eulerwalk==""){#
    		ver <- which(coords[,1]==0 && coords[,2]==0)#
				eulerwalk <- paste(ver)#
				eulerwalk
} else {
ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste(eulerwalk, ",", ver)
eulerwalk
}
eulerwalk <- ""
if(eulerwalk==""){#
    		ver <- which(coords[,1]==0 && coords[,2]==0)#
				eulerwalk <- paste0(ver)#
				eulerwalk
} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, " ,", ver)
}
if(eulerwalk==""){#
    		ver <- which(coords[,1]==0 && coords[,2]==0)#
				eulerwalk <- paste0(ver)#
				eulerwalk
} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, " ,", ver)
eulerwalk
}
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
				eulerwalk <- paste0(ver)#
				eulerwalk#
    		output$walk <- renderText(eulerwalk)#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText(eulerwalk)#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message"),#
				textOutput("walk")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
#
    		output$walk <- renderText({paste0(ver)})#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
#
    		output$walk <- renderText({paste0(ver)})#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
#
    		output$walk <- renderText({paste0(as.character(ver))})#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		h3("Click on vertices to do your Euler walk"), #
		textOutput("walk")#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		output$walk <- renderText({paste0(as.character(ver))})#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("walk")#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
	  output$walk <- renderText(		h3("Click on vertices to do your Euler walk"))#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		output$walk <- renderText({paste0(as.character(ver))})#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("walk")#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
	  output$walk <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
    		output$walk <- renderText({paste0(as.character(ver))})#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]==input$plot_click$x && coords[,2]==input$plot_click$y)#
#
    		output$walk <- renderText({paste0(as.character(ver))})#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
				output$walk <- ".."#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
				output$walk <- renderText("..")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]%in%c((input$plot_click$x-1):(input$plot_click$x+1), 0.0001) && coords[,2]==c((input$plot_click$y-1):(input$plot_click$y+1), 0.0001))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
coords[,1]
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]%in%c((input$plot_click$x-0.001):(input$plot_click$x+0.01), 0.0001) && coords[,2]==c((input$plot_click$y-0.01):(input$plot_click$y+0.01), 0.0001))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
c((1-0.001):(1+0.01), 0.0001)
c((1-0.001):(1+0.01), by = 0.0001)
c((1-0.001):(1+0.01), by = 0.0001)
c((1-0.001):(1+0.01), 0.0001)
?c()
?c()
c(0.001,(1-0.001):(1+0.01) )
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]> (input$plot_click$x-0.001) & coords[,1]<(input$plot_click$x+0.01), 0.0001)&& coords[,2]> (input$plot_click$y-0.001) & coords[,2]<(input$plot_click$y+0.01), 0.0001))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]> (input$plot_click$x-0.001) & coords[,1]<(input$plot_click$x+0.01), 0.0001)&& coords[,2]> (input$plot_click$y-0.001) & coords[,2]<(input$plot_click$y+0.01), 0.0001))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1]> (input$plot_click$x-0.001) & coords[,1]<(input$plot_click$x+0.01), 0.0001)&& coords[,2]> (input$plot_click$y-0.001) & coords[,2]<(input$plot_click$y+0.01), 0.0001))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01), 0.0001)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01), 0.0001))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01), 0.0001)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01), 0.0001))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}
observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01), 0.0001)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}
observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] == 0 && coords[,2]==0)#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				output$walk <- renderText("")#
    	} else {#
				ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				output$walk <- renderText(ver)#
    	} else {#
				ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				output$walk <- renderText(ver)#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
tkplot(dfgraph)
library(tcl)
tkplot(dfgraph)
library(tkplot)
tkplot
tkplot(net <- graph( edges=c(1,2, 2,3, 3, 1), n=3, directed=F ))
net <- graph( edges=c(1,2, 2,3, 3, 1), n=3, directed=F )
tkplot(net)
tcltk2_1.2-10.tar.gz   02-Mar-2014 12:41   814K
tcltk2_1.2-10.tar.gz   02-Mar-2014 12:41   814K
tcltk2_1.2-10.tar.gz
tcltk2_1.2-10.tar.gz   02-Mar-2014 12:41   814K
install.packages("tokp")
tkplot(dfgraph)
tkplot
tkplot(graph)
tkplog(dfgraph)
tkplot(dfgraph)
apt-get install tcl8.5-dev tk8.5-dev
library("tcltk")
capabilities()["tcltk"]#
tcltk #
FALSE
capabilities()["tcltk"]
tkplot
tkplot(edges_)
tkplot(edges_df)
tkplot(dfgraph)
tkplot(dfgraph)
library(tkplot)
tkplot(dfgraph)
library(tkrplot)
library(tkrplot)
library(tkRplotR)
tkplot(dfgraph)
library(tcltk2)
library("tcltk2")
tkplot(dfgraph)
tcltk2(dfgraph)
tkplot
tkplot(graph)
tkplot(dfgraph)
library(tkplot)
library(igraph)
library(tkplot)
library(tkplot)
tkplot(dfgraph)
library(tcl)
libary(tk)
library(tk)
tkplot(dfgraph)
install.packages("tcltk")
install.packages("tcltk2")
install.packages("tcltk")
library("tcltk")
library("tcltk2")
library("tcltk2")
library("tcltk2")
library("tcltk")
install.packages("XQuartz")
tkplot(dfgraph)
r1 <- 3.7 #distance to outer pentagon
V <- matrix(nrow = 60, ncol = 2)
V
V[1:5,1] <- r1*(cos((0:4)*0.4*pi-0.5*pi))#
    V[1:5,2] <- r1*(sin((0:4)*0.4*pi-0.5*pi))
V
(40+72+20+70+30)/(50+78+20+78+30)
(5.3+1.4+3.5+7.3+6.6+3.6+5.78+7.07+5.2166+4.55+6.34+9)/82
(5.3+1.4+3.5+7.3+6.6+3.6+5.78+7.07+5.2166+4.55+6.34+9)
(40+65.66+20+73+30)/(50+78+20+78+30)
65.6566/82*55
(44+40+20+70+30)/(50+55+20+78+30)
(50+40+20+70+30)/(50+55+20+78+30)
(50+45+20+73+30)/(50+55+20+78+30)
(44+40+20+60+30)/(50+55+20+78+30)
(40++70+30)/(50+55+20+78+30)
50/55*82
5.3+1.4+3.5+7.3+6.6+3.6+5.78+7.07
40.55/49
70/78
50/55
50/55*82
65.66/82
65.66/82*55
(44+40+20+30+70)/(55+50+20+30+78)
(50+40+20+30+70)/(55+50+20+30+78)
(50+40+20+40+70)/(55+50+20+30+78)
(50+40+20+40+70)/(55+50+20+40+78)
(50+40+20+30+70)/(55+50+20+30+78)
(44+40+20+30+70)/(55+50+20+30+78)
(65.6566+30)/(82+35)
(65.6566+30)/(82+35)*55
65.66/82*55
(45+40+20+70+30)/(55+50+20+78+30)
(44+40+20+70+30)/(55+50+20+78+30)
78-70
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				output$walk <- renderText(ver)#
    	} else {#
				ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)
library(rsconnect)
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK')
#GroupD6#
setwd('/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/A4Calc')#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
library(rsconnect)#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
source("buttonrows.R")#
ui <- dashboardPage(#
    dashboardHeader(title = "Group D6, rotational symmetries of the hexagon",#
                    titleWidth = 500),#
    dashboardSidebar(disable = TRUE),#
    dashboardBody(#
        fluidRow(#
            column(width=4,#
                   box(#
                       width = NULL,#
                       height = 450,#
                       h3 ("Elements of the group"),#
                       h4("The identity"),#
                       controlRow1("ctrlI"),#
                       h4("Order 6 elements (rotations through 60 degrees)"),#
                       controlRow4(#
                           c("ctrl123456", "ctrl135246", "ctrl142536")#
                       ),   #
                       controlRow4(#
                           c( "ctrl153264", "ctrl165432")#
                       ),   #
                       h4("Order 2 elements (flips through 180 degrees)"),#
                       controlRow3(#
                           c("ctrl2635", "ctrl123645", "ctrl1346")#
                       ),#
                       controlRow3(#
                           c("ctrl142356", "ctrl162534", "ctrl1524")#
                       ),#
                   ),#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Subgroups",#
                         buttonRow3(#
                           inputIds = c("btnC2", "btnC3", "btnC6"),#
                           labels = list("Show C2", "ShowC3", "ShowC6"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )   #
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Cosets",#
                         buttonRow2(#
                           inputIds = c("btnLC", "btnRC"),#
                           labels = list("Left Cosets", "Right Cosets"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )  #agb#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Conjugate Subgroup",#
                         buttonRow2(#
                           inputIds = c("btnmark", "btnconj"),#
                           labels = list("Select a", "Generate Subgroup"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("conjmsg"))#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Generate a Subgroup",#
                         buttonRow4(#
                           inputIds = c("btnmarkgena", "btnmarkgenb", "btngen", "btnclear"),#
                           labels = list("Generator a", "Generator b","Generate","Clear"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("genmsg"))#
                       )#box#
            ),#
            #col#
            column(#
                width = 8,#
                box(#
                  width = NULL,#
                  height = 380,#
                  fluidRow(#
                    column(#
                      width = 8,#
                      h3("Inputs and Products"),#
                      htmlOutput("results"),#
                      tags$head(tags$style("#results{color:red; font-size:20px; font-style:italic; #
overflow-y:scroll; max-height: 300px; background: ghostwhite;}"))#
                    ),#
                    column(#
                      width = 4,#
                      actionBttn("reset", "Clear Inputs and Products")#
                    )#
                  )#
                ),#
                box(width = NULL,#
                    height = 430,#
                    tableOutput("multable")#
                )#
            )#
        )  #fluid#
    )  #
)#
source("d6calc.R")#
source("permutecalc.R")#
#Global variables accessible to server()#
N <- 12#
D6DF <- makeD6data()#
#colors for cosets#
color.list <- c("pink","aquamarine","beige","hotpink", "violet")#
#Output to display in the text box#
result.list <- ""#
#Result of all multiplications so far#
product <- "I"#
subgroup <- numeric(0)#
conjugating <- FALSE#
generating <- 0#
a <-"I"#
gena <- "I"#
genb <- "I"#
#Computes a product as specified by "a" and "b" in vector v#
evaluate <- function(v,a,b) {#
  result <- "I"#
  for (i in 1:length(v)){#
    result <- Perm.multiply(result,ifelse(v[i]=="a",a,b))#
  }#
  return (result)#
}#
server <- function(input, output, session) {#
  #Elements in the chosen subgroup#
  displayButton <- function(i) {#
    renderUI({actionButton(D6DF[i,1],D6DF[i,2],#
                           style=paste("padding:4px;#
                   font-size:120%;background:",D6DF[i,3]))}) #
  }#
  #show all the buttons#
  showButtons <- function() {#
    output$ctrl2635 <- displayButton(1)#
    output$ctrl123645<- displayButton(2)                                     #
    output$ctrl1346<- displayButton(3)#
    output$ctrl142356<- displayButton(4)#
    output$ctrl162534 <- displayButton(5)#
    output$ctrl1524<- displayButton(6)                                     #
    output$ctrl165432<- displayButton(7)#
    output$ctrl153264<- displayButton(8)#
    output$ctrl142536 <- displayButton(9)#
    output$ctrl135246<- displayButton(10)                                     #
    output$ctrl123456<- displayButton(11)#
    output$ctrlI<- displayButton(12)#
  }#
  showButtons()#
  #Display the multiplication table#
  tbl <- outer(D6DF[,2],D6DF[,2],Vectorize(Perm.multiply,c("a","b")))#
  colnames(tbl) <- D6DF[,2]#
  rownames(tbl) <- D6DF[,2] #
  output$multable <- renderTable(tbl,rownames = TRUE)#
#Multiplies by a specified permutation and displays all calculations so far#
    compute.and.show <- function(perm){#
      if (conjugating) {#
        a <<- perm#
        output$conjmsg <- renderUI(paste0("Conjugating by element ",perm,collapse=""))#
        conjugating <<- FALSE#
        return()#
      }#
      if (generating==1) {#
        gena <<- perm#
        output$genmsg <- renderUI(paste0("Generating with element ",gena,collapse=""))#
        return()#
      }#
      if (generating==2) {#
        genb <<- perm#
        output$genmsg <- #
          renderUI(paste0("Generating with elements ",gena," and ", genb,collapse=""))#
        return()#
      }#
      product <<- Perm.multiply(perm,product)#
      line.out <- paste(perm,product,sep = "&emsp;")#
      result.list <<- paste(result.list, line.out, "<br/>")#
      output$results<-renderUI(HTML(result.list))#
    }#
    #Marks all elements in a subgroup with a color#
    mark.subgroup <- function() {#
      for (i in 1:N){#
        D6DF$color[i] <<- ifelse(i  %in% subgroup,"yellow","gray90")#
      }#
    }#
#Event handlers for all the element buttons #
    observeEvent(input$btnI,{#
      compute.and.show("I")#
    })#
    observeEvent(input$btn2635,{#
       compute.and.show("(26)(35)")#
    })#
    observeEvent(input$btn123645,{#
      compute.and.show("(12)(36)(45)")#
    })#
    observeEvent(input$btn1346,{#
      compute.and.show("(13)(46)")#
    })#
    observeEvent(input$btn142356,{#
      compute.and.show("(14)(23)(56)")#
    })#
    observeEvent(input$btn162534,{#
      compute.and.show("(16)(25)(34)")#
    })#
    observeEvent(input$btn1524,{#
      compute.and.show("(15)(24)")#
    })#
    observeEvent(input$btn165432,{#
      compute.and.show("(165432)")#
    })#
    observeEvent(input$btn153264,{#
      compute.and.show("(153)(264)")#
    })#
    observeEvent(input$btn142536,{#
        compute.and.show("(14)(25)(36)")#
    })#
    observeEvent(input$btn135246,{#
      compute.and.show("(135)(246)")#
    })#
    observeEvent(input$btn123456,{#
      compute.and.show("(123456)")#
    })#
#The reset button clears the output and reinitializes the product#
    observeEvent(input$reset,{#
        result.list <<- ""#
        product <<- "I"#
        output$results<-renderUI(HTML(result.list))#
    })#
#Event handlers for the subgroup buttons#
    observeEvent(input$btnC2,{#
      subgroup <<- c(1,9, 12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC3,{#
      subgroup <<- c(8,10,12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC6,{#
      subgroup <<- c(7:12)#
      mark.subgroup()#
      showButtons()#
    })#
    #Event handler for left cosets#
    observeEvent(input$btnLC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[in.coset,2],D6DF[j,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    #Right cosets work the same way#
    observeEvent(input$btnRC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[j,2],D6DF[in.coset,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    observeEvent(input$btnmark,{#
      conjugating <<- TRUE#
      output$conjmsg <- renderUI("Click the button for the desired element a")#
    })#
    observeEvent(input$btnmarkgena,{#
      generating <<- 1#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator a")#
    })#
    observeEvent(input$btnmarkgenb,{#
      generating <<- 2#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator b")#
    })#
    #Generate random sequences of generators.#
    #If we generate more than half the group, it's the entire group#
    #This algorithm could turn out to be inefficient,and in principle it can fail#
    observeEvent(input$btngen,{#
      subgroup <<- numeric(0)#
      for (j in 1:(4*N)) {#
        v <- sample(c("a","b"),sample(7:10,1),replace = TRUE)#
        element <- evaluate(v,gena,genb)#
        k <- which(D6DF[,2] == element)[1]#
        if(!(k %in% subgroup)){#
          subgroup <<- c(subgroup,k)#
          D6DF[k,3] <<- "yellow"#
        }#
        #If subgroup has more than N/2 elements, it's the entire group#
        if (length(subgroup) > N/2){#
          subgroup <<- 1:N#
          break#
        } #
      }  #
      mark.subgroup()#
      showButtons()#
      output$genmsg <- #
        renderUI(paste0("The subgroup generated by ",gena," and ", genb," is now yellow"))#
    })#
    observeEvent(input$btnclear,{#
      subgroup <<- rep(FALSE,N)#
      generating <<- 0#
      gena <<- "I"#
      genb <<- "I"#
      mark.subgroup()#
      showButtons()#
      output$genmsg <- renderUI("")#
    })#
    observeEvent(input$btnconj,{#
      aInv <- Perm.inverse(a)#
      D6DF[,3] <<- rep("gray90",N)#
      for (j in 1:N) {#
        if (j %in% subgroup){#
          element <- Perm.conjugate(a,D6DF[j,2])#
          k <- which(D6DF[,2] == element)[1]#
          D6DF[k,3] <<- "pink"#
        }#
      }  #
      showButtons()#
      output$conjmsg <- renderUI(paste0("The subgroup ",a,"H",aInv," is now pink"))#
    })}#
# Run the application #
shinyApp(ui = ui, server = server)#
deployApp()
#GroupD6#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
library(rsconnect)#
#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
source("buttonrows.R")#
ui <- dashboardPage(#
    dashboardHeader(title = "Group D6, rotational symmetries of the hexagon",#
                    titleWidth = 500),#
    dashboardSidebar(disable = TRUE),#
    dashboardBody(#
        fluidRow(#
            column(width=4,#
                   box(#
                       width = NULL,#
                       height = 450,#
                       h3 ("Elements of the group"),#
                       h4("The identity"),#
                       controlRow1("ctrlI"),#
                       h4("Order 6 elements (rotations through 60 degrees)"),#
                       controlRow4(#
                           c("ctrl123456", "ctrl135246", "ctrl142536")#
                       ),   #
                       controlRow4(#
                           c( "ctrl153264", "ctrl165432")#
                       ),   #
                       h4("Order 2 elements (flips through 180 degrees)"),#
                       controlRow3(#
                           c("ctrl2635", "ctrl123645", "ctrl1346")#
                       ),#
                       controlRow3(#
                           c("ctrl142356", "ctrl162534", "ctrl1524")#
                       ),#
                   ),#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Subgroups",#
                         buttonRow3(#
                           inputIds = c("btnC2", "btnC3", "btnC6"),#
                           labels = list("Show C2", "ShowC3", "ShowC6"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )   #
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Cosets",#
                         buttonRow2(#
                           inputIds = c("btnLC", "btnRC"),#
                           labels = list("Left Cosets", "Right Cosets"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )  #agb#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Conjugate Subgroup",#
                         buttonRow2(#
                           inputIds = c("btnmark", "btnconj"),#
                           labels = list("Select a", "Generate Subgroup"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("conjmsg"))#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Generate a Subgroup",#
                         buttonRow4(#
                           inputIds = c("btnmarkgena", "btnmarkgenb", "btngen", "btnclear"),#
                           labels = list("Generator a", "Generator b","Generate","Clear"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("genmsg"))#
                       )#box#
            ),#
            #col#
            column(#
                width = 8,#
                box(#
                  width = NULL,#
                  height = 380,#
                  fluidRow(#
                    column(#
                      width = 8,#
                      h3("Inputs and Products"),#
                      htmlOutput("results"),#
                      tags$head(tags$style("#results{color:red; font-size:20px; font-style:italic; #
overflow-y:scroll; max-height: 300px; background: ghostwhite;}"))#
                    ),#
                    column(#
                      width = 4,#
                      actionBttn("reset", "Clear Inputs and Products")#
                    )#
                  )#
                ),#
                box(width = NULL,#
                    height = 430,#
                    tableOutput("multable")#
                )#
            )#
        )  #fluid#
    )  #
)#
source("d6calc.R")#
source("permutecalc.R")#
#Global variables accessible to server()#
N <- 12#
D6DF <- makeD6data()#
#colors for cosets#
color.list <- c("pink","aquamarine","beige","hotpink", "violet")#
#Output to display in the text box#
result.list <- ""#
#Result of all multiplications so far#
product <- "I"#
subgroup <- numeric(0)#
conjugating <- FALSE#
generating <- 0#
a <-"I"#
gena <- "I"#
genb <- "I"#
#Computes a product as specified by "a" and "b" in vector v#
evaluate <- function(v,a,b) {#
  result <- "I"#
  for (i in 1:length(v)){#
    result <- Perm.multiply(result,ifelse(v[i]=="a",a,b))#
  }#
  return (result)#
}#
server <- function(input, output, session) {#
  #Elements in the chosen subgroup#
  displayButton <- function(i) {#
    renderUI({actionButton(D6DF[i,1],D6DF[i,2],#
                           style=paste("padding:4px;#
                   font-size:120%;background:",D6DF[i,3]))}) #
  }#
  #show all the buttons#
  showButtons <- function() {#
    output$ctrl2635 <- displayButton(1)#
    output$ctrl123645<- displayButton(2)                                     #
    output$ctrl1346<- displayButton(3)#
    output$ctrl142356<- displayButton(4)#
    output$ctrl162534 <- displayButton(5)#
    output$ctrl1524<- displayButton(6)                                     #
    output$ctrl165432<- displayButton(7)#
    output$ctrl153264<- displayButton(8)#
    output$ctrl142536 <- displayButton(9)#
    output$ctrl135246<- displayButton(10)                                     #
    output$ctrl123456<- displayButton(11)#
    output$ctrlI<- displayButton(12)#
  }#
  showButtons()#
  #Display the multiplication table#
  tbl <- outer(D6DF[,2],D6DF[,2],Vectorize(Perm.multiply,c("a","b")))#
  colnames(tbl) <- D6DF[,2]#
  rownames(tbl) <- D6DF[,2] #
  output$multable <- renderTable(tbl,rownames = TRUE)#
#Multiplies by a specified permutation and displays all calculations so far#
    compute.and.show <- function(perm){#
      if (conjugating) {#
        a <<- perm#
        output$conjmsg <- renderUI(paste0("Conjugating by element ",perm,collapse=""))#
        conjugating <<- FALSE#
        return()#
      }#
      if (generating==1) {#
        gena <<- perm#
        output$genmsg <- renderUI(paste0("Generating with element ",gena,collapse=""))#
        return()#
      }#
      if (generating==2) {#
        genb <<- perm#
        output$genmsg <- #
          renderUI(paste0("Generating with elements ",gena," and ", genb,collapse=""))#
        return()#
      }#
      product <<- Perm.multiply(perm,product)#
      line.out <- paste(perm,product,sep = "&emsp;")#
      result.list <<- paste(result.list, line.out, "<br/>")#
      output$results<-renderUI(HTML(result.list))#
    }#
    #Marks all elements in a subgroup with a color#
    mark.subgroup <- function() {#
      for (i in 1:N){#
        D6DF$color[i] <<- ifelse(i  %in% subgroup,"yellow","gray90")#
      }#
    }#
#Event handlers for all the element buttons #
    observeEvent(input$btnI,{#
      compute.and.show("I")#
    })#
    observeEvent(input$btn2635,{#
       compute.and.show("(26)(35)")#
    })#
    observeEvent(input$btn123645,{#
      compute.and.show("(12)(36)(45)")#
    })#
    observeEvent(input$btn1346,{#
      compute.and.show("(13)(46)")#
    })#
    observeEvent(input$btn142356,{#
      compute.and.show("(14)(23)(56)")#
    })#
    observeEvent(input$btn162534,{#
      compute.and.show("(16)(25)(34)")#
    })#
    observeEvent(input$btn1524,{#
      compute.and.show("(15)(24)")#
    })#
    observeEvent(input$btn165432,{#
      compute.and.show("(165432)")#
    })#
    observeEvent(input$btn153264,{#
      compute.and.show("(153)(264)")#
    })#
    observeEvent(input$btn142536,{#
        compute.and.show("(14)(25)(36)")#
    })#
    observeEvent(input$btn135246,{#
      compute.and.show("(135)(246)")#
    })#
    observeEvent(input$btn123456,{#
      compute.and.show("(123456)")#
    })#
#The reset button clears the output and reinitializes the product#
    observeEvent(input$reset,{#
        result.list <<- ""#
        product <<- "I"#
        output$results<-renderUI(HTML(result.list))#
    })#
#Event handlers for the subgroup buttons#
    observeEvent(input$btnC2,{#
      subgroup <<- c(1,9, 12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC3,{#
      subgroup <<- c(8,10,12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC6,{#
      subgroup <<- c(7:12)#
      mark.subgroup()#
      showButtons()#
    })#
    #Event handler for left cosets#
    observeEvent(input$btnLC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[in.coset,2],D6DF[j,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    #Right cosets work the same way#
    observeEvent(input$btnRC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[j,2],D6DF[in.coset,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    observeEvent(input$btnmark,{#
      conjugating <<- TRUE#
      output$conjmsg <- renderUI("Click the button for the desired element a")#
    })#
    observeEvent(input$btnmarkgena,{#
      generating <<- 1#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator a")#
    })#
    observeEvent(input$btnmarkgenb,{#
      generating <<- 2#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator b")#
    })#
    #Generate random sequences of generators.#
    #If we generate more than half the group, it's the entire group#
    #This algorithm could turn out to be inefficient,and in principle it can fail#
    observeEvent(input$btngen,{#
      subgroup <<- numeric(0)#
      for (j in 1:(4*N)) {#
        v <- sample(c("a","b"),sample(7:10,1),replace = TRUE)#
        element <- evaluate(v,gena,genb)#
        k <- which(D6DF[,2] == element)[1]#
        if(!(k %in% subgroup)){#
          subgroup <<- c(subgroup,k)#
          D6DF[k,3] <<- "yellow"#
        }#
        #If subgroup has more than N/2 elements, it's the entire group#
        if (length(subgroup) > N/2){#
          subgroup <<- 1:N#
          break#
        } #
      }  #
      mark.subgroup()#
      showButtons()#
      output$genmsg <- #
        renderUI(paste0("The subgroup generated by ",gena," and ", genb," is now yellow"))#
    })#
    observeEvent(input$btnclear,{#
      subgroup <<- rep(FALSE,N)#
      generating <<- 0#
      gena <<- "I"#
      genb <<- "I"#
      mark.subgroup()#
      showButtons()#
      output$genmsg <- renderUI("")#
    })#
    observeEvent(input$btnconj,{#
      aInv <- Perm.inverse(a)#
      D6DF[,3] <<- rep("gray90",N)#
      for (j in 1:N) {#
        if (j %in% subgroup){#
          element <- Perm.conjugate(a,D6DF[j,2])#
          k <- which(D6DF[,2] == element)[1]#
          D6DF[k,3] <<- "pink"#
        }#
      }  #
      showButtons()#
      output$conjmsg <- renderUI(paste0("The subgroup ",a,"H",aInv," is now pink"))#
    })}#
# Run the application #
shinyApp(ui = ui, server = server)#
deployApp()
getwd()
getwd() <- NULL
#GroupD6#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
library(rsconnect)#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
source("buttonrows.R")#
ui <- dashboardPage(#
    dashboardHeader(title = "Group D6, rotational symmetries of the hexagon",#
                    titleWidth = 500),#
    dashboardSidebar(disable = TRUE),#
    dashboardBody(#
        fluidRow(#
            column(width=4,#
                   box(#
                       width = NULL,#
                       height = 450,#
                       h3 ("Elements of the group"),#
                       h4("The identity"),#
                       controlRow1("ctrlI"),#
                       h4("Order 6 elements (rotations through 60 degrees)"),#
                       controlRow4(#
                           c("ctrl123456", "ctrl135246", "ctrl142536")#
                       ),   #
                       controlRow4(#
                           c( "ctrl153264", "ctrl165432")#
                       ),   #
                       h4("Order 2 elements (flips through 180 degrees)"),#
                       controlRow3(#
                           c("ctrl2635", "ctrl123645", "ctrl1346")#
                       ),#
                       controlRow3(#
                           c("ctrl142356", "ctrl162534", "ctrl1524")#
                       ),#
                   ),#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Subgroups",#
                         buttonRow3(#
                           inputIds = c("btnC2", "btnC3", "btnC6"),#
                           labels = list("Show C2", "ShowC3", "ShowC6"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )   #
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Cosets",#
                         buttonRow2(#
                           inputIds = c("btnLC", "btnRC"),#
                           labels = list("Left Cosets", "Right Cosets"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )  #agb#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Conjugate Subgroup",#
                         buttonRow2(#
                           inputIds = c("btnmark", "btnconj"),#
                           labels = list("Select a", "Generate Subgroup"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("conjmsg"))#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Generate a Subgroup",#
                         buttonRow4(#
                           inputIds = c("btnmarkgena", "btnmarkgenb", "btngen", "btnclear"),#
                           labels = list("Generator a", "Generator b","Generate","Clear"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("genmsg"))#
                       )#box#
            ),#
            #col#
            column(#
                width = 8,#
                box(#
                  width = NULL,#
                  height = 380,#
                  fluidRow(#
                    column(#
                      width = 8,#
                      h3("Inputs and Products"),#
                      htmlOutput("results"),#
                      tags$head(tags$style("#results{color:red; font-size:20px; font-style:italic; #
overflow-y:scroll; max-height: 300px; background: ghostwhite;}"))#
                    ),#
                    column(#
                      width = 4,#
                      actionBttn("reset", "Clear Inputs and Products")#
                    )#
                  )#
                ),#
                box(width = NULL,#
                    height = 430,#
                    tableOutput("multable")#
                )#
            )#
        )  #fluid#
    )  #
)#
source("d6calc.R")#
source("permutecalc.R")#
#Global variables accessible to server()#
N <- 12#
D6DF <- makeD6data()#
#colors for cosets#
color.list <- c("pink","aquamarine","beige","hotpink", "violet")#
#Output to display in the text box#
result.list <- ""#
#Result of all multiplications so far#
product <- "I"#
subgroup <- numeric(0)#
conjugating <- FALSE#
generating <- 0#
a <-"I"#
gena <- "I"#
genb <- "I"#
#Computes a product as specified by "a" and "b" in vector v#
evaluate <- function(v,a,b) {#
  result <- "I"#
  for (i in 1:length(v)){#
    result <- Perm.multiply(result,ifelse(v[i]=="a",a,b))#
  }#
  return (result)#
}#
server <- function(input, output, session) {#
  #Elements in the chosen subgroup#
  displayButton <- function(i) {#
    renderUI({actionButton(D6DF[i,1],D6DF[i,2],#
                           style=paste("padding:4px;#
                   font-size:120%;background:",D6DF[i,3]))}) #
  }#
  #show all the buttons#
  showButtons <- function() {#
    output$ctrl2635 <- displayButton(1)#
    output$ctrl123645<- displayButton(2)                                     #
    output$ctrl1346<- displayButton(3)#
    output$ctrl142356<- displayButton(4)#
    output$ctrl162534 <- displayButton(5)#
    output$ctrl1524<- displayButton(6)                                     #
    output$ctrl165432<- displayButton(7)#
    output$ctrl153264<- displayButton(8)#
    output$ctrl142536 <- displayButton(9)#
    output$ctrl135246<- displayButton(10)                                     #
    output$ctrl123456<- displayButton(11)#
    output$ctrlI<- displayButton(12)#
  }#
  showButtons()#
  #Display the multiplication table#
  tbl <- outer(D6DF[,2],D6DF[,2],Vectorize(Perm.multiply,c("a","b")))#
  colnames(tbl) <- D6DF[,2]#
  rownames(tbl) <- D6DF[,2] #
  output$multable <- renderTable(tbl,rownames = TRUE)#
#Multiplies by a specified permutation and displays all calculations so far#
    compute.and.show <- function(perm){#
      if (conjugating) {#
        a <<- perm#
        output$conjmsg <- renderUI(paste0("Conjugating by element ",perm,collapse=""))#
        conjugating <<- FALSE#
        return()#
      }#
      if (generating==1) {#
        gena <<- perm#
        output$genmsg <- renderUI(paste0("Generating with element ",gena,collapse=""))#
        return()#
      }#
      if (generating==2) {#
        genb <<- perm#
        output$genmsg <- #
          renderUI(paste0("Generating with elements ",gena," and ", genb,collapse=""))#
        return()#
      }#
      product <<- Perm.multiply(perm,product)#
      line.out <- paste(perm,product,sep = "&emsp;")#
      result.list <<- paste(result.list, line.out, "<br/>")#
      output$results<-renderUI(HTML(result.list))#
    }#
    #Marks all elements in a subgroup with a color#
    mark.subgroup <- function() {#
      for (i in 1:N){#
        D6DF$color[i] <<- ifelse(i  %in% subgroup,"yellow","gray90")#
      }#
    }#
#Event handlers for all the element buttons #
    observeEvent(input$btnI,{#
      compute.and.show("I")#
    })#
    observeEvent(input$btn2635,{#
       compute.and.show("(26)(35)")#
    })#
    observeEvent(input$btn123645,{#
      compute.and.show("(12)(36)(45)")#
    })#
    observeEvent(input$btn1346,{#
      compute.and.show("(13)(46)")#
    })#
    observeEvent(input$btn142356,{#
      compute.and.show("(14)(23)(56)")#
    })#
    observeEvent(input$btn162534,{#
      compute.and.show("(16)(25)(34)")#
    })#
    observeEvent(input$btn1524,{#
      compute.and.show("(15)(24)")#
    })#
    observeEvent(input$btn165432,{#
      compute.and.show("(165432)")#
    })#
    observeEvent(input$btn153264,{#
      compute.and.show("(153)(264)")#
    })#
    observeEvent(input$btn142536,{#
        compute.and.show("(14)(25)(36)")#
    })#
    observeEvent(input$btn135246,{#
      compute.and.show("(135)(246)")#
    })#
    observeEvent(input$btn123456,{#
      compute.and.show("(123456)")#
    })#
#The reset button clears the output and reinitializes the product#
    observeEvent(input$reset,{#
        result.list <<- ""#
        product <<- "I"#
        output$results<-renderUI(HTML(result.list))#
    })#
#Event handlers for the subgroup buttons#
    observeEvent(input$btnC2,{#
      subgroup <<- c(1,9, 12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC3,{#
      subgroup <<- c(8,10,12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC6,{#
      subgroup <<- c(7:12)#
      mark.subgroup()#
      showButtons()#
    })#
    #Event handler for left cosets#
    observeEvent(input$btnLC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[in.coset,2],D6DF[j,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    #Right cosets work the same way#
    observeEvent(input$btnRC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[j,2],D6DF[in.coset,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    observeEvent(input$btnmark,{#
      conjugating <<- TRUE#
      output$conjmsg <- renderUI("Click the button for the desired element a")#
    })#
    observeEvent(input$btnmarkgena,{#
      generating <<- 1#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator a")#
    })#
    observeEvent(input$btnmarkgenb,{#
      generating <<- 2#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator b")#
    })#
    #Generate random sequences of generators.#
    #If we generate more than half the group, it's the entire group#
    #This algorithm could turn out to be inefficient,and in principle it can fail#
    observeEvent(input$btngen,{#
      subgroup <<- numeric(0)#
      for (j in 1:(4*N)) {#
        v <- sample(c("a","b"),sample(7:10,1),replace = TRUE)#
        element <- evaluate(v,gena,genb)#
        k <- which(D6DF[,2] == element)[1]#
        if(!(k %in% subgroup)){#
          subgroup <<- c(subgroup,k)#
          D6DF[k,3] <<- "yellow"#
        }#
        #If subgroup has more than N/2 elements, it's the entire group#
        if (length(subgroup) > N/2){#
          subgroup <<- 1:N#
          break#
        } #
      }  #
      mark.subgroup()#
      showButtons()#
      output$genmsg <- #
        renderUI(paste0("The subgroup generated by ",gena," and ", genb," is now yellow"))#
    })#
    observeEvent(input$btnclear,{#
      subgroup <<- rep(FALSE,N)#
      generating <<- 0#
      gena <<- "I"#
      genb <<- "I"#
      mark.subgroup()#
      showButtons()#
      output$genmsg <- renderUI("")#
    })#
    observeEvent(input$btnconj,{#
      aInv <- Perm.inverse(a)#
      D6DF[,3] <<- rep("gray90",N)#
      for (j in 1:N) {#
        if (j %in% subgroup){#
          element <- Perm.conjugate(a,D6DF[j,2])#
          k <- which(D6DF[,2] == element)[1]#
          D6DF[k,3] <<- "pink"#
        }#
      }  #
      showButtons()#
      output$conjmsg <- renderUI(paste0("The subgroup ",a,"H",aInv," is now pink"))#
    })}#
# Run the application #
shinyApp(ui = ui, server = server)#
deployApp()
#GroupD6#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
library(rsconnect)#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
source("buttonrows.R")#
ui <- dashboardPage(#
    dashboardHeader(title = "Group D6, rotational symmetries of the hexagon",#
                    titleWidth = 500),#
    dashboardSidebar(disable = TRUE),#
    dashboardBody(#
        fluidRow(#
            column(width=4,#
                   box(#
                       width = NULL,#
                       height = 450,#
                       h3 ("Elements of the group"),#
                       h4("The identity"),#
                       controlRow1("ctrlI"),#
                       h4("Order 6 elements (rotations through 60 degrees)"),#
                       controlRow4(#
                           c("ctrl123456", "ctrl135246", "ctrl142536")#
                       ),   #
                       controlRow4(#
                           c( "ctrl153264", "ctrl165432")#
                       ),   #
                       h4("Order 2 elements (flips through 180 degrees)"),#
                       controlRow3(#
                           c("ctrl2635", "ctrl123645", "ctrl1346")#
                       ),#
                       controlRow3(#
                           c("ctrl142356", "ctrl162534", "ctrl1524")#
                       ),#
                   ),#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Subgroups",#
                         buttonRow3(#
                           inputIds = c("btnC2", "btnC3", "btnC6"),#
                           labels = list("Show C2", "ShowC3", "ShowC6"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )   #
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Cosets",#
                         buttonRow2(#
                           inputIds = c("btnLC", "btnRC"),#
                           labels = list("Left Cosets", "Right Cosets"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )  #agb#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Conjugate Subgroup",#
                         buttonRow2(#
                           inputIds = c("btnmark", "btnconj"),#
                           labels = list("Select a", "Generate Subgroup"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("conjmsg"))#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Generate a Subgroup",#
                         buttonRow4(#
                           inputIds = c("btnmarkgena", "btnmarkgenb", "btngen", "btnclear"),#
                           labels = list("Generator a", "Generator b","Generate","Clear"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("genmsg"))#
                       )#box#
            ),#
            #col#
            column(#
                width = 8,#
                box(#
                  width = NULL,#
                  height = 380,#
                  fluidRow(#
                    column(#
                      width = 8,#
                      h3("Inputs and Products"),#
                      htmlOutput("results"),#
                      tags$head(tags$style("#results{color:red; font-size:20px; font-style:italic; #
overflow-y:scroll; max-height: 300px; background: ghostwhite;}"))#
                    ),#
                    column(#
                      width = 4,#
                      actionBttn("reset", "Clear Inputs and Products")#
                    )#
                  )#
                ),#
                box(width = NULL,#
                    height = 430,#
                    tableOutput("multable")#
                )#
            )#
        )  #fluid#
    )  #
)#
source("d6calc.R")#
source("permutecalc.R")#
#Global variables accessible to server()#
N <- 12#
D6DF <- makeD6data()#
#colors for cosets#
color.list <- c("pink","aquamarine","beige","hotpink", "violet")#
#Output to display in the text box#
result.list <- ""#
#Result of all multiplications so far#
product <- "I"#
subgroup <- numeric(0)#
conjugating <- FALSE#
generating <- 0#
a <-"I"#
gena <- "I"#
genb <- "I"#
#Computes a product as specified by "a" and "b" in vector v#
evaluate <- function(v,a,b) {#
  result <- "I"#
  for (i in 1:length(v)){#
    result <- Perm.multiply(result,ifelse(v[i]=="a",a,b))#
  }#
  return (result)#
}#
server <- function(input, output, session) {#
  #Elements in the chosen subgroup#
  displayButton <- function(i) {#
    renderUI({actionButton(D6DF[i,1],D6DF[i,2],#
                           style=paste("padding:4px;#
                   font-size:120%;background:",D6DF[i,3]))}) #
  }#
  #show all the buttons#
  showButtons <- function() {#
    output$ctrl2635 <- displayButton(1)#
    output$ctrl123645<- displayButton(2)                                     #
    output$ctrl1346<- displayButton(3)#
    output$ctrl142356<- displayButton(4)#
    output$ctrl162534 <- displayButton(5)#
    output$ctrl1524<- displayButton(6)                                     #
    output$ctrl165432<- displayButton(7)#
    output$ctrl153264<- displayButton(8)#
    output$ctrl142536 <- displayButton(9)#
    output$ctrl135246<- displayButton(10)                                     #
    output$ctrl123456<- displayButton(11)#
    output$ctrlI<- displayButton(12)#
  }#
  showButtons()#
  #Display the multiplication table#
  tbl <- outer(D6DF[,2],D6DF[,2],Vectorize(Perm.multiply,c("a","b")))#
  colnames(tbl) <- D6DF[,2]#
  rownames(tbl) <- D6DF[,2] #
  output$multable <- renderTable(tbl,rownames = TRUE)#
#Multiplies by a specified permutation and displays all calculations so far#
    compute.and.show <- function(perm){#
      if (conjugating) {#
        a <<- perm#
        output$conjmsg <- renderUI(paste0("Conjugating by element ",perm,collapse=""))#
        conjugating <<- FALSE#
        return()#
      }#
      if (generating==1) {#
        gena <<- perm#
        output$genmsg <- renderUI(paste0("Generating with element ",gena,collapse=""))#
        return()#
      }#
      if (generating==2) {#
        genb <<- perm#
        output$genmsg <- #
          renderUI(paste0("Generating with elements ",gena," and ", genb,collapse=""))#
        return()#
      }#
      product <<- Perm.multiply(perm,product)#
      line.out <- paste(perm,product,sep = "&emsp;")#
      result.list <<- paste(result.list, line.out, "<br/>")#
      output$results<-renderUI(HTML(result.list))#
    }#
    #Marks all elements in a subgroup with a color#
    mark.subgroup <- function() {#
      for (i in 1:N){#
        D6DF$color[i] <<- ifelse(i  %in% subgroup,"yellow","gray90")#
      }#
    }#
#Event handlers for all the element buttons #
    observeEvent(input$btnI,{#
      compute.and.show("I")#
    })#
    observeEvent(input$btn2635,{#
       compute.and.show("(26)(35)")#
    })#
    observeEvent(input$btn123645,{#
      compute.and.show("(12)(36)(45)")#
    })#
    observeEvent(input$btn1346,{#
      compute.and.show("(13)(46)")#
    })#
    observeEvent(input$btn142356,{#
      compute.and.show("(14)(23)(56)")#
    })#
    observeEvent(input$btn162534,{#
      compute.and.show("(16)(25)(34)")#
    })#
    observeEvent(input$btn1524,{#
      compute.and.show("(15)(24)")#
    })#
    observeEvent(input$btn165432,{#
      compute.and.show("(165432)")#
    })#
    observeEvent(input$btn153264,{#
      compute.and.show("(153)(264)")#
    })#
    observeEvent(input$btn142536,{#
        compute.and.show("(14)(25)(36)")#
    })#
    observeEvent(input$btn135246,{#
      compute.and.show("(135)(246)")#
    })#
    observeEvent(input$btn123456,{#
      compute.and.show("(123456)")#
    })#
#The reset button clears the output and reinitializes the product#
    observeEvent(input$reset,{#
        result.list <<- ""#
        product <<- "I"#
        output$results<-renderUI(HTML(result.list))#
    })#
#Event handlers for the subgroup buttons#
    observeEvent(input$btnC2,{#
      subgroup <<- c(1,9, 12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC3,{#
      subgroup <<- c(8,10,12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC6,{#
      subgroup <<- c(7:12)#
      mark.subgroup()#
      showButtons()#
    })#
    #Event handler for left cosets#
    observeEvent(input$btnLC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[in.coset,2],D6DF[j,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    #Right cosets work the same way#
    observeEvent(input$btnRC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[j,2],D6DF[in.coset,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    observeEvent(input$btnmark,{#
      conjugating <<- TRUE#
      output$conjmsg <- renderUI("Click the button for the desired element a")#
    })#
    observeEvent(input$btnmarkgena,{#
      generating <<- 1#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator a")#
    })#
    observeEvent(input$btnmarkgenb,{#
      generating <<- 2#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator b")#
    })#
    #Generate random sequences of generators.#
    #If we generate more than half the group, it's the entire group#
    #This algorithm could turn out to be inefficient,and in principle it can fail#
    observeEvent(input$btngen,{#
      subgroup <<- numeric(0)#
      for (j in 1:(4*N)) {#
        v <- sample(c("a","b"),sample(7:10,1),replace = TRUE)#
        element <- evaluate(v,gena,genb)#
        k <- which(D6DF[,2] == element)[1]#
        if(!(k %in% subgroup)){#
          subgroup <<- c(subgroup,k)#
          D6DF[k,3] <<- "yellow"#
        }#
        #If subgroup has more than N/2 elements, it's the entire group#
        if (length(subgroup) > N/2){#
          subgroup <<- 1:N#
          break#
        } #
      }  #
      mark.subgroup()#
      showButtons()#
      output$genmsg <- #
        renderUI(paste0("The subgroup generated by ",gena," and ", genb," is now yellow"))#
    })#
    observeEvent(input$btnclear,{#
      subgroup <<- rep(FALSE,N)#
      generating <<- 0#
      gena <<- "I"#
      genb <<- "I"#
      mark.subgroup()#
      showButtons()#
      output$genmsg <- renderUI("")#
    })#
    observeEvent(input$btnconj,{#
      aInv <- Perm.inverse(a)#
      D6DF[,3] <<- rep("gray90",N)#
      for (j in 1:N) {#
        if (j %in% subgroup){#
          element <- Perm.conjugate(a,D6DF[j,2])#
          k <- which(D6DF[,2] == element)[1]#
          D6DF[k,3] <<- "pink"#
        }#
      }  #
      showButtons()#
      output$conjmsg <- renderUI(paste0("The subgroup ",a,"H",aInv," is now pink"))#
    })}#
# Run the application #
shinyApp(ui = ui, server = server)#
deployApp()
getwd()
ls()
rm()
getwd()
#GroupD6#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
library(rsconnect)#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
source("buttonrows.R")#
ui <- dashboardPage(#
    dashboardHeader(title = "Group D6, rotational symmetries of the hexagon",#
                    titleWidth = 500),#
    dashboardSidebar(disable = TRUE),#
    dashboardBody(#
        fluidRow(#
            column(width=4,#
                   box(#
                       width = NULL,#
                       height = 450,#
                       h3 ("Elements of the group"),#
                       h4("The identity"),#
                       controlRow1("ctrlI"),#
                       h4("Order 6 elements (rotations through 60 degrees)"),#
                       controlRow4(#
                           c("ctrl123456", "ctrl135246", "ctrl142536")#
                       ),   #
                       controlRow4(#
                           c( "ctrl153264", "ctrl165432")#
                       ),   #
                       h4("Order 2 elements (flips through 180 degrees)"),#
                       controlRow3(#
                           c("ctrl2635", "ctrl123645", "ctrl1346")#
                       ),#
                       controlRow3(#
                           c("ctrl142356", "ctrl162534", "ctrl1524")#
                       ),#
                   ),#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Subgroups",#
                         buttonRow3(#
                           inputIds = c("btnC2", "btnC3", "btnC6"),#
                           labels = list("Show C2", "ShowC3", "ShowC6"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )   #
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Cosets",#
                         buttonRow2(#
                           inputIds = c("btnLC", "btnRC"),#
                           labels = list("Left Cosets", "Right Cosets"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )  #agb#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Conjugate Subgroup",#
                         buttonRow2(#
                           inputIds = c("btnmark", "btnconj"),#
                           labels = list("Select a", "Generate Subgroup"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("conjmsg"))#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Generate a Subgroup",#
                         buttonRow4(#
                           inputIds = c("btnmarkgena", "btnmarkgenb", "btngen", "btnclear"),#
                           labels = list("Generator a", "Generator b","Generate","Clear"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("genmsg"))#
                       )#box#
            ),#
            #col#
            column(#
                width = 8,#
                box(#
                  width = NULL,#
                  height = 380,#
                  fluidRow(#
                    column(#
                      width = 8,#
                      h3("Inputs and Products"),#
                      htmlOutput("results"),#
                      tags$head(tags$style("#results{color:red; font-size:20px; font-style:italic; #
overflow-y:scroll; max-height: 300px; background: ghostwhite;}"))#
                    ),#
                    column(#
                      width = 4,#
                      actionBttn("reset", "Clear Inputs and Products")#
                    )#
                  )#
                ),#
                box(width = NULL,#
                    height = 430,#
                    tableOutput("multable")#
                )#
            )#
        )  #fluid#
    )  #
)#
source("d6calc.R")#
source("permutecalc.R")#
#Global variables accessible to server()#
N <- 12#
D6DF <- makeD6data()#
#colors for cosets#
color.list <- c("pink","aquamarine","beige","hotpink", "violet")#
#Output to display in the text box#
result.list <- ""#
#Result of all multiplications so far#
product <- "I"#
subgroup <- numeric(0)#
conjugating <- FALSE#
generating <- 0#
a <-"I"#
gena <- "I"#
genb <- "I"#
#Computes a product as specified by "a" and "b" in vector v#
evaluate <- function(v,a,b) {#
  result <- "I"#
  for (i in 1:length(v)){#
    result <- Perm.multiply(result,ifelse(v[i]=="a",a,b))#
  }#
  return (result)#
}#
server <- function(input, output, session) {#
  #Elements in the chosen subgroup#
  displayButton <- function(i) {#
    renderUI({actionButton(D6DF[i,1],D6DF[i,2],#
                           style=paste("padding:4px;#
                   font-size:120%;background:",D6DF[i,3]))}) #
  }#
  #show all the buttons#
  showButtons <- function() {#
    output$ctrl2635 <- displayButton(1)#
    output$ctrl123645<- displayButton(2)                                     #
    output$ctrl1346<- displayButton(3)#
    output$ctrl142356<- displayButton(4)#
    output$ctrl162534 <- displayButton(5)#
    output$ctrl1524<- displayButton(6)                                     #
    output$ctrl165432<- displayButton(7)#
    output$ctrl153264<- displayButton(8)#
    output$ctrl142536 <- displayButton(9)#
    output$ctrl135246<- displayButton(10)                                     #
    output$ctrl123456<- displayButton(11)#
    output$ctrlI<- displayButton(12)#
  }#
  showButtons()#
  #Display the multiplication table#
  tbl <- outer(D6DF[,2],D6DF[,2],Vectorize(Perm.multiply,c("a","b")))#
  colnames(tbl) <- D6DF[,2]#
  rownames(tbl) <- D6DF[,2] #
  output$multable <- renderTable(tbl,rownames = TRUE)#
#Multiplies by a specified permutation and displays all calculations so far#
    compute.and.show <- function(perm){#
      if (conjugating) {#
        a <<- perm#
        output$conjmsg <- renderUI(paste0("Conjugating by element ",perm,collapse=""))#
        conjugating <<- FALSE#
        return()#
      }#
      if (generating==1) {#
        gena <<- perm#
        output$genmsg <- renderUI(paste0("Generating with element ",gena,collapse=""))#
        return()#
      }#
      if (generating==2) {#
        genb <<- perm#
        output$genmsg <- #
          renderUI(paste0("Generating with elements ",gena," and ", genb,collapse=""))#
        return()#
      }#
      product <<- Perm.multiply(perm,product)#
      line.out <- paste(perm,product,sep = "&emsp;")#
      result.list <<- paste(result.list, line.out, "<br/>")#
      output$results<-renderUI(HTML(result.list))#
    }#
    #Marks all elements in a subgroup with a color#
    mark.subgroup <- function() {#
      for (i in 1:N){#
        D6DF$color[i] <<- ifelse(i  %in% subgroup,"yellow","gray90")#
      }#
    }#
#Event handlers for all the element buttons #
    observeEvent(input$btnI,{#
      compute.and.show("I")#
    })#
    observeEvent(input$btn2635,{#
       compute.and.show("(26)(35)")#
    })#
    observeEvent(input$btn123645,{#
      compute.and.show("(12)(36)(45)")#
    })#
    observeEvent(input$btn1346,{#
      compute.and.show("(13)(46)")#
    })#
    observeEvent(input$btn142356,{#
      compute.and.show("(14)(23)(56)")#
    })#
    observeEvent(input$btn162534,{#
      compute.and.show("(16)(25)(34)")#
    })#
    observeEvent(input$btn1524,{#
      compute.and.show("(15)(24)")#
    })#
    observeEvent(input$btn165432,{#
      compute.and.show("(165432)")#
    })#
    observeEvent(input$btn153264,{#
      compute.and.show("(153)(264)")#
    })#
    observeEvent(input$btn142536,{#
        compute.and.show("(14)(25)(36)")#
    })#
    observeEvent(input$btn135246,{#
      compute.and.show("(135)(246)")#
    })#
    observeEvent(input$btn123456,{#
      compute.and.show("(123456)")#
    })#
#The reset button clears the output and reinitializes the product#
    observeEvent(input$reset,{#
        result.list <<- ""#
        product <<- "I"#
        output$results<-renderUI(HTML(result.list))#
    })#
#Event handlers for the subgroup buttons#
    observeEvent(input$btnC2,{#
      subgroup <<- c(1,9, 12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC3,{#
      subgroup <<- c(8,10,12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC6,{#
      subgroup <<- c(7:12)#
      mark.subgroup()#
      showButtons()#
    })#
    #Event handler for left cosets#
    observeEvent(input$btnLC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[in.coset,2],D6DF[j,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    #Right cosets work the same way#
    observeEvent(input$btnRC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[j,2],D6DF[in.coset,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    observeEvent(input$btnmark,{#
      conjugating <<- TRUE#
      output$conjmsg <- renderUI("Click the button for the desired element a")#
    })#
    observeEvent(input$btnmarkgena,{#
      generating <<- 1#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator a")#
    })#
    observeEvent(input$btnmarkgenb,{#
      generating <<- 2#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator b")#
    })#
    #Generate random sequences of generators.#
    #If we generate more than half the group, it's the entire group#
    #This algorithm could turn out to be inefficient,and in principle it can fail#
    observeEvent(input$btngen,{#
      subgroup <<- numeric(0)#
      for (j in 1:(4*N)) {#
        v <- sample(c("a","b"),sample(7:10,1),replace = TRUE)#
        element <- evaluate(v,gena,genb)#
        k <- which(D6DF[,2] == element)[1]#
        if(!(k %in% subgroup)){#
          subgroup <<- c(subgroup,k)#
          D6DF[k,3] <<- "yellow"#
        }#
        #If subgroup has more than N/2 elements, it's the entire group#
        if (length(subgroup) > N/2){#
          subgroup <<- 1:N#
          break#
        } #
      }  #
      mark.subgroup()#
      showButtons()#
      output$genmsg <- #
        renderUI(paste0("The subgroup generated by ",gena," and ", genb," is now yellow"))#
    })#
    observeEvent(input$btnclear,{#
      subgroup <<- rep(FALSE,N)#
      generating <<- 0#
      gena <<- "I"#
      genb <<- "I"#
      mark.subgroup()#
      showButtons()#
      output$genmsg <- renderUI("")#
    })#
    observeEvent(input$btnconj,{#
      aInv <- Perm.inverse(a)#
      D6DF[,3] <<- rep("gray90",N)#
      for (j in 1:N) {#
        if (j %in% subgroup){#
          element <- Perm.conjugate(a,D6DF[j,2])#
          k <- which(D6DF[,2] == element)[1]#
          D6DF[k,3] <<- "pink"#
        }#
      }  #
      showButtons()#
      output$conjmsg <- renderUI(paste0("The subgroup ",a,"H",aInv," is now pink"))#
    })}#
# Run the application #
shinyApp(ui = ui, server = server)#
deployApp()
#GroupD6#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
library(rsconnect)#
source("buttonrows.R")#
ui <- dashboardPage(#
    dashboardHeader(title = "Group D6, rotational symmetries of the hexagon",#
                    titleWidth = 500),#
    dashboardSidebar(disable = TRUE),#
    dashboardBody(#
        fluidRow(#
            column(width=4,#
                   box(#
                       width = NULL,#
                       height = 450,#
                       h3 ("Elements of the group"),#
                       h4("The identity"),#
                       controlRow1("ctrlI"),#
                       h4("Order 6 elements (rotations through 60 degrees)"),#
                       controlRow4(#
                           c("ctrl123456", "ctrl135246", "ctrl142536")#
                       ),   #
                       controlRow4(#
                           c( "ctrl153264", "ctrl165432")#
                       ),   #
                       h4("Order 2 elements (flips through 180 degrees)"),#
                       controlRow3(#
                           c("ctrl2635", "ctrl123645", "ctrl1346")#
                       ),#
                       controlRow3(#
                           c("ctrl142356", "ctrl162534", "ctrl1524")#
                       ),#
                   ),#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Subgroups",#
                         buttonRow3(#
                           inputIds = c("btnC2", "btnC3", "btnC6"),#
                           labels = list("Show C2", "ShowC3", "ShowC6"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )   #
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Cosets",#
                         buttonRow2(#
                           inputIds = c("btnLC", "btnRC"),#
                           labels = list("Left Cosets", "Right Cosets"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )  #agb#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Conjugate Subgroup",#
                         buttonRow2(#
                           inputIds = c("btnmark", "btnconj"),#
                           labels = list("Select a", "Generate Subgroup"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("conjmsg"))#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Generate a Subgroup",#
                         buttonRow4(#
                           inputIds = c("btnmarkgena", "btnmarkgenb", "btngen", "btnclear"),#
                           labels = list("Generator a", "Generator b","Generate","Clear"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("genmsg"))#
                       )#box#
            ),#
            #col#
            column(#
                width = 8,#
                box(#
                  width = NULL,#
                  height = 380,#
                  fluidRow(#
                    column(#
                      width = 8,#
                      h3("Inputs and Products"),#
                      htmlOutput("results"),#
                      tags$head(tags$style("#results{color:red; font-size:20px; font-style:italic; #
overflow-y:scroll; max-height: 300px; background: ghostwhite;}"))#
                    ),#
                    column(#
                      width = 4,#
                      actionBttn("reset", "Clear Inputs and Products")#
                    )#
                  )#
                ),#
                box(width = NULL,#
                    height = 430,#
                    tableOutput("multable")#
                )#
            )#
        )  #fluid#
    )  #
)#
source("d6calc.R")#
source("permutecalc.R")#
#Global variables accessible to server()#
N <- 12#
D6DF <- makeD6data()#
#colors for cosets#
color.list <- c("pink","aquamarine","beige","hotpink", "violet")#
#Output to display in the text box#
result.list <- ""#
#Result of all multiplications so far#
product <- "I"#
subgroup <- numeric(0)#
conjugating <- FALSE#
generating <- 0#
a <-"I"#
gena <- "I"#
genb <- "I"#
#Computes a product as specified by "a" and "b" in vector v#
evaluate <- function(v,a,b) {#
  result <- "I"#
  for (i in 1:length(v)){#
    result <- Perm.multiply(result,ifelse(v[i]=="a",a,b))#
  }#
  return (result)#
}#
server <- function(input, output, session) {#
  #Elements in the chosen subgroup#
  displayButton <- function(i) {#
    renderUI({actionButton(D6DF[i,1],D6DF[i,2],#
                           style=paste("padding:4px;#
                   font-size:120%;background:",D6DF[i,3]))}) #
  }#
  #show all the buttons#
  showButtons <- function() {#
    output$ctrl2635 <- displayButton(1)#
    output$ctrl123645<- displayButton(2)                                     #
    output$ctrl1346<- displayButton(3)#
    output$ctrl142356<- displayButton(4)#
    output$ctrl162534 <- displayButton(5)#
    output$ctrl1524<- displayButton(6)                                     #
    output$ctrl165432<- displayButton(7)#
    output$ctrl153264<- displayButton(8)#
    output$ctrl142536 <- displayButton(9)#
    output$ctrl135246<- displayButton(10)                                     #
    output$ctrl123456<- displayButton(11)#
    output$ctrlI<- displayButton(12)#
  }#
  showButtons()#
  #Display the multiplication table#
  tbl <- outer(D6DF[,2],D6DF[,2],Vectorize(Perm.multiply,c("a","b")))#
  colnames(tbl) <- D6DF[,2]#
  rownames(tbl) <- D6DF[,2] #
  output$multable <- renderTable(tbl,rownames = TRUE)#
#Multiplies by a specified permutation and displays all calculations so far#
    compute.and.show <- function(perm){#
      if (conjugating) {#
        a <<- perm#
        output$conjmsg <- renderUI(paste0("Conjugating by element ",perm,collapse=""))#
        conjugating <<- FALSE#
        return()#
      }#
      if (generating==1) {#
        gena <<- perm#
        output$genmsg <- renderUI(paste0("Generating with element ",gena,collapse=""))#
        return()#
      }#
      if (generating==2) {#
        genb <<- perm#
        output$genmsg <- #
          renderUI(paste0("Generating with elements ",gena," and ", genb,collapse=""))#
        return()#
      }#
      product <<- Perm.multiply(perm,product)#
      line.out <- paste(perm,product,sep = "&emsp;")#
      result.list <<- paste(result.list, line.out, "<br/>")#
      output$results<-renderUI(HTML(result.list))#
    }#
    #Marks all elements in a subgroup with a color#
    mark.subgroup <- function() {#
      for (i in 1:N){#
        D6DF$color[i] <<- ifelse(i  %in% subgroup,"yellow","gray90")#
      }#
    }#
#Event handlers for all the element buttons #
    observeEvent(input$btnI,{#
      compute.and.show("I")#
    })#
    observeEvent(input$btn2635,{#
       compute.and.show("(26)(35)")#
    })#
    observeEvent(input$btn123645,{#
      compute.and.show("(12)(36)(45)")#
    })#
    observeEvent(input$btn1346,{#
      compute.and.show("(13)(46)")#
    })#
    observeEvent(input$btn142356,{#
      compute.and.show("(14)(23)(56)")#
    })#
    observeEvent(input$btn162534,{#
      compute.and.show("(16)(25)(34)")#
    })#
    observeEvent(input$btn1524,{#
      compute.and.show("(15)(24)")#
    })#
    observeEvent(input$btn165432,{#
      compute.and.show("(165432)")#
    })#
    observeEvent(input$btn153264,{#
      compute.and.show("(153)(264)")#
    })#
    observeEvent(input$btn142536,{#
        compute.and.show("(14)(25)(36)")#
    })#
    observeEvent(input$btn135246,{#
      compute.and.show("(135)(246)")#
    })#
    observeEvent(input$btn123456,{#
      compute.and.show("(123456)")#
    })#
#The reset button clears the output and reinitializes the product#
    observeEvent(input$reset,{#
        result.list <<- ""#
        product <<- "I"#
        output$results<-renderUI(HTML(result.list))#
    })#
#Event handlers for the subgroup buttons#
    observeEvent(input$btnC2,{#
      subgroup <<- c(1,9, 12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC3,{#
      subgroup <<- c(8,10,12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC6,{#
      subgroup <<- c(7:12)#
      mark.subgroup()#
      showButtons()#
    })#
    #Event handler for left cosets#
    observeEvent(input$btnLC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[in.coset,2],D6DF[j,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    #Right cosets work the same way#
    observeEvent(input$btnRC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[j,2],D6DF[in.coset,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    observeEvent(input$btnmark,{#
      conjugating <<- TRUE#
      output$conjmsg <- renderUI("Click the button for the desired element a")#
    })#
    observeEvent(input$btnmarkgena,{#
      generating <<- 1#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator a")#
    })#
    observeEvent(input$btnmarkgenb,{#
      generating <<- 2#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator b")#
    })#
    #Generate random sequences of generators.#
    #If we generate more than half the group, it's the entire group#
    #This algorithm could turn out to be inefficient,and in principle it can fail#
    observeEvent(input$btngen,{#
      subgroup <<- numeric(0)#
      for (j in 1:(4*N)) {#
        v <- sample(c("a","b"),sample(7:10,1),replace = TRUE)#
        element <- evaluate(v,gena,genb)#
        k <- which(D6DF[,2] == element)[1]#
        if(!(k %in% subgroup)){#
          subgroup <<- c(subgroup,k)#
          D6DF[k,3] <<- "yellow"#
        }#
        #If subgroup has more than N/2 elements, it's the entire group#
        if (length(subgroup) > N/2){#
          subgroup <<- 1:N#
          break#
        } #
      }  #
      mark.subgroup()#
      showButtons()#
      output$genmsg <- #
        renderUI(paste0("The subgroup generated by ",gena," and ", genb," is now yellow"))#
    })#
    observeEvent(input$btnclear,{#
      subgroup <<- rep(FALSE,N)#
      generating <<- 0#
      gena <<- "I"#
      genb <<- "I"#
      mark.subgroup()#
      showButtons()#
      output$genmsg <- renderUI("")#
    })#
    observeEvent(input$btnconj,{#
      aInv <- Perm.inverse(a)#
      D6DF[,3] <<- rep("gray90",N)#
      for (j in 1:N) {#
        if (j %in% subgroup){#
          element <- Perm.conjugate(a,D6DF[j,2])#
          k <- which(D6DF[,2] == element)[1]#
          D6DF[k,3] <<- "pink"#
        }#
      }  #
      showButtons()#
      output$conjmsg <- renderUI(paste0("The subgroup ",a,"H",aInv," is now pink"))#
    })}#
# Run the application #
shinyApp(ui = ui, server = server)#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
deployApp()
#GroupD6#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
library(rsconnect)#
source("buttonrows.R")#
ui <- dashboardPage(#
    dashboardHeader(title = "Group D6, rotational symmetries of the hexagon",#
                    titleWidth = 500),#
    dashboardSidebar(disable = TRUE),#
    dashboardBody(#
        fluidRow(#
            column(width=4,#
                   box(#
                       width = NULL,#
                       height = 450,#
                       h3 ("Elements of the group"),#
                       h4("The identity"),#
                       controlRow1("ctrlI"),#
                       h4("Order 6 elements (rotations through 60 degrees)"),#
                       controlRow4(#
                           c("ctrl123456", "ctrl135246", "ctrl142536")#
                       ),   #
                       controlRow4(#
                           c( "ctrl153264", "ctrl165432")#
                       ),   #
                       h4("Order 2 elements (flips through 180 degrees)"),#
                       controlRow3(#
                           c("ctrl2635", "ctrl123645", "ctrl1346")#
                       ),#
                       controlRow3(#
                           c("ctrl142356", "ctrl162534", "ctrl1524")#
                       ),#
                   ),#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Subgroups",#
                         buttonRow3(#
                           inputIds = c("btnC2", "btnC3", "btnC6"),#
                           labels = list("Show C2", "ShowC3", "ShowC6"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )   #
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 100,#
                         title = "Cosets",#
                         buttonRow2(#
                           inputIds = c("btnLC", "btnRC"),#
                           labels = list("Left Cosets", "Right Cosets"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         )  #agb#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Conjugate Subgroup",#
                         buttonRow2(#
                           inputIds = c("btnmark", "btnconj"),#
                           labels = list("Select a", "Generate Subgroup"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("conjmsg"))#
                       ),#box#
                       box(#
                         width = NULL,#
                         height = 120,#
                         title = "Generate a Subgroup",#
                         buttonRow4(#
                           inputIds = c("btnmarkgena", "btnmarkgenb", "btngen", "btnclear"),#
                           labels = list("Generator a", "Generator b","Generate","Clear"),#
                           btnStyle = "padding:4px;font-size:120%"#
                         ),  #
                         h4(uiOutput("genmsg"))#
                       )#box#
            ),#
            #col#
            column(#
                width = 8,#
                box(#
                  width = NULL,#
                  height = 380,#
                  fluidRow(#
                    column(#
                      width = 8,#
                      h3("Inputs and Products"),#
                      htmlOutput("results"),#
                      tags$head(tags$style("#results{color:red; font-size:20px; font-style:italic; #
overflow-y:scroll; max-height: 300px; background: ghostwhite;}"))#
                    ),#
                    column(#
                      width = 4,#
                      actionBttn("reset", "Clear Inputs and Products")#
                    )#
                  )#
                ),#
                box(width = NULL,#
                    height = 430,#
                    tableOutput("multable")#
                )#
            )#
        )  #fluid#
    )  #
)#
source("d6calc.R")#
source("permutecalc.R")#
#Global variables accessible to server()#
N <- 12#
D6DF <- makeD6data()#
#colors for cosets#
color.list <- c("pink","aquamarine","beige","hotpink", "violet")#
#Output to display in the text box#
result.list <- ""#
#Result of all multiplications so far#
product <- "I"#
subgroup <- numeric(0)#
conjugating <- FALSE#
generating <- 0#
a <-"I"#
gena <- "I"#
genb <- "I"#
#Computes a product as specified by "a" and "b" in vector v#
evaluate <- function(v,a,b) {#
  result <- "I"#
  for (i in 1:length(v)){#
    result <- Perm.multiply(result,ifelse(v[i]=="a",a,b))#
  }#
  return (result)#
}#
server <- function(input, output, session) {#
  #Elements in the chosen subgroup#
  displayButton <- function(i) {#
    renderUI({actionButton(D6DF[i,1],D6DF[i,2],#
                           style=paste("padding:4px;#
                   font-size:120%;background:",D6DF[i,3]))}) #
  }#
  #show all the buttons#
  showButtons <- function() {#
    output$ctrl2635 <- displayButton(1)#
    output$ctrl123645<- displayButton(2)                                     #
    output$ctrl1346<- displayButton(3)#
    output$ctrl142356<- displayButton(4)#
    output$ctrl162534 <- displayButton(5)#
    output$ctrl1524<- displayButton(6)                                     #
    output$ctrl165432<- displayButton(7)#
    output$ctrl153264<- displayButton(8)#
    output$ctrl142536 <- displayButton(9)#
    output$ctrl135246<- displayButton(10)                                     #
    output$ctrl123456<- displayButton(11)#
    output$ctrlI<- displayButton(12)#
  }#
  showButtons()#
  #Display the multiplication table#
  tbl <- outer(D6DF[,2],D6DF[,2],Vectorize(Perm.multiply,c("a","b")))#
  colnames(tbl) <- D6DF[,2]#
  rownames(tbl) <- D6DF[,2] #
  output$multable <- renderTable(tbl,rownames = TRUE)#
#Multiplies by a specified permutation and displays all calculations so far#
    compute.and.show <- function(perm){#
      if (conjugating) {#
        a <<- perm#
        output$conjmsg <- renderUI(paste0("Conjugating by element ",perm,collapse=""))#
        conjugating <<- FALSE#
        return()#
      }#
      if (generating==1) {#
        gena <<- perm#
        output$genmsg <- renderUI(paste0("Generating with element ",gena,collapse=""))#
        return()#
      }#
      if (generating==2) {#
        genb <<- perm#
        output$genmsg <- #
          renderUI(paste0("Generating with elements ",gena," and ", genb,collapse=""))#
        return()#
      }#
      product <<- Perm.multiply(perm,product)#
      line.out <- paste(perm,product,sep = "&emsp;")#
      result.list <<- paste(result.list, line.out, "<br/>")#
      output$results<-renderUI(HTML(result.list))#
    }#
    #Marks all elements in a subgroup with a color#
    mark.subgroup <- function() {#
      for (i in 1:N){#
        D6DF$color[i] <<- ifelse(i  %in% subgroup,"yellow","gray90")#
      }#
    }#
#Event handlers for all the element buttons #
    observeEvent(input$btnI,{#
      compute.and.show("I")#
    })#
    observeEvent(input$btn2635,{#
       compute.and.show("(26)(35)")#
    })#
    observeEvent(input$btn123645,{#
      compute.and.show("(12)(36)(45)")#
    })#
    observeEvent(input$btn1346,{#
      compute.and.show("(13)(46)")#
    })#
    observeEvent(input$btn142356,{#
      compute.and.show("(14)(23)(56)")#
    })#
    observeEvent(input$btn162534,{#
      compute.and.show("(16)(25)(34)")#
    })#
    observeEvent(input$btn1524,{#
      compute.and.show("(15)(24)")#
    })#
    observeEvent(input$btn165432,{#
      compute.and.show("(165432)")#
    })#
    observeEvent(input$btn153264,{#
      compute.and.show("(153)(264)")#
    })#
    observeEvent(input$btn142536,{#
        compute.and.show("(14)(25)(36)")#
    })#
    observeEvent(input$btn135246,{#
      compute.and.show("(135)(246)")#
    })#
    observeEvent(input$btn123456,{#
      compute.and.show("(123456)")#
    })#
#The reset button clears the output and reinitializes the product#
    observeEvent(input$reset,{#
        result.list <<- ""#
        product <<- "I"#
        output$results<-renderUI(HTML(result.list))#
    })#
#Event handlers for the subgroup buttons#
    observeEvent(input$btnC2,{#
      subgroup <<- c(1,9, 12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC3,{#
      subgroup <<- c(8,10,12)#
      mark.subgroup()#
      showButtons()#
    })#
    observeEvent(input$btnC6,{#
      subgroup <<- c(7:12)#
      mark.subgroup()#
      showButtons()#
    })#
    #Event handler for left cosets#
    observeEvent(input$btnLC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[in.coset,2],D6DF[j,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    #Right cosets work the same way#
    observeEvent(input$btnRC,{#
      mark.subgroup()#
      idx = 1   #index into the color list -- one for each coset#
      #Keep creating cosets as long as there are elements that are still gray#
      while(length(which(D6DF$color == "gray90") >0)){#
        #Find the first unassigned group element#
        in.coset <- which(D6DF$color == "gray90")[1]#
        #Generate its left coset and put a new color on the buttons#
        for (j in 1:N) {#
          if(j %in% subgroup) {#
            element <- Perm.multiply(D6DF[j,2],D6DF[in.coset,2])#
            k <- which(D6DF[,2] == element)#
            D6DF[k,3] <<- color.list[idx]#
          }#
        }#
        idx <- idx + 1#
      }#
      showButtons()#
    })#
    observeEvent(input$btnmark,{#
      conjugating <<- TRUE#
      output$conjmsg <- renderUI("Click the button for the desired element a")#
    })#
    observeEvent(input$btnmarkgena,{#
      generating <<- 1#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator a")#
    })#
    observeEvent(input$btnmarkgenb,{#
      generating <<- 2#
      D6DF[,3] <<- rep("gray90",N)#
      showButtons()#
      output$genmsg <- renderUI("Click the button for generator b")#
    })#
    #Generate random sequences of generators.#
    #If we generate more than half the group, it's the entire group#
    #This algorithm could turn out to be inefficient,and in principle it can fail#
    observeEvent(input$btngen,{#
      subgroup <<- numeric(0)#
      for (j in 1:(4*N)) {#
        v <- sample(c("a","b"),sample(7:10,1),replace = TRUE)#
        element <- evaluate(v,gena,genb)#
        k <- which(D6DF[,2] == element)[1]#
        if(!(k %in% subgroup)){#
          subgroup <<- c(subgroup,k)#
          D6DF[k,3] <<- "yellow"#
        }#
        #If subgroup has more than N/2 elements, it's the entire group#
        if (length(subgroup) > N/2){#
          subgroup <<- 1:N#
          break#
        } #
      }  #
      mark.subgroup()#
      showButtons()#
      output$genmsg <- #
        renderUI(paste0("The subgroup generated by ",gena," and ", genb," is now yellow"))#
    })#
    observeEvent(input$btnclear,{#
      subgroup <<- rep(FALSE,N)#
      generating <<- 0#
      gena <<- "I"#
      genb <<- "I"#
      mark.subgroup()#
      showButtons()#
      output$genmsg <- renderUI("")#
    })#
    observeEvent(input$btnconj,{#
      aInv <- Perm.inverse(a)#
      D6DF[,3] <<- rep("gray90",N)#
      for (j in 1:N) {#
        if (j %in% subgroup){#
          element <- Perm.conjugate(a,D6DF[j,2])#
          k <- which(D6DF[,2] == element)[1]#
          D6DF[k,3] <<- "pink"#
        }#
      }  #
      showButtons()#
      output$conjmsg <- renderUI(paste0("The subgroup ",a,"H",aInv," is now pink"))#
    })}#
# Run the application #
shinyApp(ui = ui, server = server)#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
deployApp()
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				output$walk <- renderText(ver)#
    	} else {#
				ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)#
#
library(rsconnect)#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
deployApp()
#Starter file for any Shiny dashboard app#
#This should replace the default app.r that displays Old Faithful data#
#The user interface#
header <- dashboardHeader(title = "Modular Multiplication")#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      numericInput("q", label = "q", value = 5),#
          )#
          ),#
  fluidRow(#
    column( 12,  #
    actionButton("btndisplay", "Display Table")#
    )#
)#
)#
body <- dashboardBody(#
  fluidRow(#
    column(#
      width = 12,#
             h3("Multiplication Table"),#
      dataTableOutput("multable", height =600)#
    )#
  ),#
    fluidRow(#
    column(#
      width = 12,#
             h3("Order of Elements"),#
      plotOutput("orders", height =300)#
    )#
  ) #
)#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that implement the mathematics#
source("modular.R")#
#
#Variables that are shared among server functions#
	MDF <- M.makeDataFrame(q)#
	q <- 5#
#Functions that read the input and modify the output and input#
shinyServer <- function(input, output, session) {#
	tbl <-outer(MDF$coprime, MDF$coprime, vM.multiply, q = q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
#
	orders <-(sapply(DF$coprime, vM.orders, q = q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
	observeEvent(input$btndisplay,{#
		MDF <- M.makeDataFrame(input$q)#
		  tbl <-outer(MDF$coprime, M.orders, q = input$q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
	orders <-(sapply(DF$coprime, vM.orders, q = input$q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
  })#
#
}#
#Run the app#
shinyApp(ui = ui, server = server)#
#
library(rsconnect)#
runApp()#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
deployApp()
# Fleury's Algorithm#
library(shiny)#
library(shinydashboard)#
library(shinyWidgets)#
#
header <- dashboardHeader(title = "Euler Walks",#
                          titleWidth = 600#
                          )#
#setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/EulerWalk")                         #
source("FleurysWalk.R")#
#
body <- dashboardBody( #
	fluidRow(#
		column(12,#
		h2("This graph permits an Euler walk"),#
		plotOutput("graph", height = 600, click = "plot_click")#
		)#
	),#
	fluidRow(#
		column(12,#
		textOutput("message")#
		),#
	fluidRow(#
		column(12,#
		textOutput("walk"),#
		)#
	)#
)#
)#
sidebar <- dashboardSidebar(#
  fluidRow(#
    column(12,  #
      sliderInput(inputId = "n_vertices",#
                  label = "Number of Vertices",#
                  min = 6,#
                  max = 12,#
                  value = 1)#
#
    )#
   ),#
  fluidRow(#
    column(12,  #
    actionButton("btngenerate", "Generate New Graph")#
    )#
	)#
)#
#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that read the input and modify the output and input#
server <- function(session, input, output) {#
    edges_df <- euler.makeDataFrame(6)#
    eulerwalk <- ""#
    observeEvent(input$btngenerate, {#
    	edges_df <- euler.makeDataFrame(input$n_vertices)#
    	node_names <- c(1:nrow(edges_df))#
		dfgraph <<- graph_from_data_frame(edges_df, directed = FALSE, vertices = node_names) #
		coords <<- layout_(dfgraph, as_star())#
	  output$graph <- renderPlot(plot(dfgraph, layout=coords))#
    	output$message <- renderText("Click on vertices to do your Euler walk")#
    })#
    observeEvent(input$plot_click, {#
    	if(eulerwalk==""){#
    		ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				output$walk <- renderText(ver)#
    	} else {#
				ver <- which(coords[,1] > (input$plot_click$x-0.001) && coords[,1]<(input$plot_click$x+0.01)&& coords[,2]> (input$plot_click$y-0.001) && coords[,2]<(input$plot_click$y+0.01))#
				eulerwalk <- paste0(eulerwalk, ", ", ver)#
				output$walk <- renderText({eulerwalk})#
    		output$graph <- renderPlot(plot(dfgraph, layout=coords, edge.color = "red"))		#
    	}#
	})#
}#
#Run the app#
shinyApp(ui = ui, server = server)#
#
library(rsconnect)#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
deployApp()
#Starter file for any Shiny dashboard app#
#This should replace the default app.r that displays Old Faithful data#
#The user interface#
header <- dashboardHeader(title = "Modular Multiplication")#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      numericInput("q", label = "q", value = 5),#
          )#
          ),#
  fluidRow(#
    column( 12,  #
    actionButton("btndisplay", "Display Table")#
    )#
)#
)#
body <- dashboardBody(#
  fluidRow(#
    column(#
      width = 12,#
             h3("Multiplication Table"),#
      dataTableOutput("multable", height =600)#
    )#
  ),#
    fluidRow(#
    column(#
      width = 12,#
             h3("Order of Elements"),#
      plotOutput("orders", height =300)#
    )#
  ) #
)#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that implement the mathematics#
source("modular.R")#
#
#Variables that are shared among server functions#
	MDF <- M.makeDataFrame(q)#
	q <- 5#
#Functions that read the input and modify the output and input#
shinyServer <- function(input, output, session) {#
	tbl <-outer(MDF$coprime, MDF$coprime, vM.multiply, q = q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
#
	orders <-(sapply(DF$coprime, vM.orders, q = q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
	observeEvent(input$btndisplay,{#
		MDF <- M.makeDataFrame(input$q)#
		  tbl <-outer(MDF$coprime, M.orders, q = input$q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
	orders <-(sapply(DF$coprime, vM.orders, q = input$q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
  })#
#
}#
#Run the app#
shinyApp(ui = ui, server = server)#
#
library(rsconnect)#
runApp()#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
deployApp()
#Starter file for any Shiny dashboard app#
#This should replace the default app.r that displays Old Faithful data#
#
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/Modular")#
#
#The user interface#
header <- dashboardHeader(title = "Modular Multiplication")#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      numericInput("q", label = "q", value = 5),#
          )#
          ),#
  fluidRow(#
    column( 12,  #
    actionButton("btndisplay", "Display Table")#
    )#
)#
)#
body <- dashboardBody(#
  fluidRow(#
    column(#
      width = 12,#
             h3("Multiplication Table"),#
      dataTableOutput("multable", height =600)#
    )#
  ),#
    fluidRow(#
    column(#
      width = 12,#
             h3("Order of Elements"),#
      plotOutput("orders", height =300)#
    )#
  ) #
)#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that implement the mathematics#
source("modular.R")#
#
#Variables that are shared among server functions#
	MDF <- M.makeDataFrame(q)#
	q <- 5#
#Functions that read the input and modify the output and input#
shinyServer <- function(input, output, session) {#
	tbl <-outer(MDF$coprime, MDF$coprime, vM.multiply, q = q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
#
	orders <-(sapply(DF$coprime, vM.orders, q = q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
	observeEvent(input$btndisplay,{#
		MDF <- M.makeDataFrame(input$q)#
		  tbl <-outer(MDF$coprime, M.orders, q = input$q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
	orders <-(sapply(DF$coprime, vM.orders, q = input$q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
  })#
#
}#
#Run the app#
shinyApp(ui = ui, server = server)#
#
library(rsconnect)#
runApp()#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
deployApp()
setwd("/Users/hyeongjihyeon/OneDrive - nyu.edu/Dashboard/Modular")
#The user interface#
header <- dashboardHeader(title = "Modular Multiplication")#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      numericInput("q", label = "q", value = 5),#
          )#
          ),#
  fluidRow(#
    column( 12,  #
    actionButton("btndisplay", "Display Table")#
    )#
)#
)
body <- dashboardBody(#
  fluidRow(#
    column(#
      width = 12,#
             h3("Multiplication Table"),#
      dataTableOutput("multable", height =600)#
    )#
  ),#
    fluidRow(#
    column(#
      width = 12,#
             h3("Order of Elements"),#
      plotOutput("orders", height =300)#
    )#
  ) #
)#
ui <- dashboardPage(header, sidebar, body)
body <- dashboardBody(#
  fluidRow(#
    column(#
      width = 12,#
             h3("Multiplication Table"),#
      dataTableOutput("multable")#
    )#
  ),#
    fluidRow(#
    column(#
      width = 12,#
             h3("Order of Elements"),#
      plotOutput("orders", height =300)#
    )#
  ) #
)#
ui <- dashboardPage(header, sidebar, body)
#Functions that implement the mathematics#
source("modular.R")#
#
#Variables that are shared among server functions#
	MDF <- M.makeDataFrame(q)#
	q <- 5#
#Functions that read the input and modify the output and input#
shinyServer <- function(input, output, session) {#
	tbl <-outer(MDF$coprime, MDF$coprime, vM.multiply, q = q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
#
	orders <-(sapply(DF$coprime, vM.orders, q = q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
	observeEvent(input$btndisplay,{#
		MDF <- M.makeDataFrame(input$q)#
		  tbl <-outer(MDF$coprime, M.orders, q = input$q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
	orders <-(sapply(DF$coprime, vM.orders, q = input$q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
  })#
#
}#
#Run the app#
shinyApp(ui = ui, server = server)#
#
library(rsconnect)#
runApp()#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
deployApp()
#Starter file for any Shiny dashboard app#
#This should replace the default app.r that displays Old Faithful data#
#The user interface#
header <- dashboardHeader(title = "Modular Multiplication")#
sidebar <- dashboardSidebar(#
  width = 200,#
  fluidRow(#
    column(12,  #
      numericInput("q", label = "q", value = 5),#
          )#
          ),#
  fluidRow(#
    column( 12,  #
    actionButton("btndisplay", "Display Table")#
    )#
)#
)#
body <- dashboardBody(#
  fluidRow(#
    column(#
      width = 12,#
             h3("Multiplication Table"),#
      dataTableOutput("multable")#
    )#
  ),#
    fluidRow(#
    column(#
      width = 12,#
             h3("Order of Elements"),#
      plotOutput("orders", height =300)#
    )#
  ) #
)#
ui <- dashboardPage(header, sidebar, body)#
#
#Functions that implement the mathematics#
source("modular.R")#
#
#Variables that are shared among server functions#
	MDF <- M.makeDataFrame(q)#
	q <- 5#
#Functions that read the input and modify the output and input#
shinyServer <- function(input, output, session) {#
	tbl <-outer(MDF$coprime, MDF$coprime, vM.multiply, q = q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
#
	orders <-(sapply(DF$coprime, vM.orders, q = q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
	observeEvent(input$btndisplay,{#
		MDF <- M.makeDataFrame(input$q)#
		  tbl <-outer(MDF$coprime, M.orders, q = input$q)#
  colnames(tbl) <- MDF$coprime#
  rownames(tbl) <- MDF$coprime#
  output$multable <- renderDataTable(tbl, options = list(dom = "t"))#
	orders <-(sapply(DF$coprime, vM.orders, q = input$q))#
	table(orders)#
	output$orders <- renderPlot({#
    barplot(table(orders))#
    text(orders, labels = DF$coprime)#
  }, res = 96)#
  })#
#
}#
#Run the app#
shinyApp(ui = ui, server = server)#
#
library(rsconnect)#
runApp()#
rsconnect::setAccountInfo(name='jihyeonhyeong', token='0C17F16C75FCAEB7B057D9E361586951', secret='+okLcveFtZbVAZeHoOW9/3ZSmijsHoDyUjPRnqyK') #
deployApp()
